// Copyright 2015 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package structure

import (
	"bytes"
	"encoding/binary"
	"strconv"

	"github.com/pingcap/errors"
	"github.com/pingcap/tidb/kv"
	"github.com/pingcap/tidb/trace_util_0"
)

// HashPair is the pair for (field, value) in a hash.
type HashPair struct {
	Field []byte
	Value []byte
}

type hashMeta struct {
	FieldCount int64
}

func (meta hashMeta) Value() []byte {
	trace_util_0.Count(_hash_00000, 0)
	buf := make([]byte, 8)
	binary.BigEndian.PutUint64(buf[0:8], uint64(meta.FieldCount))
	return buf
}

func (meta hashMeta) IsEmpty() bool {
	trace_util_0.Count(_hash_00000, 1)
	return meta.FieldCount <= 0
}

// HSet sets the string value of a hash field.
func (t *TxStructure) HSet(key []byte, field []byte, value []byte) error {
	trace_util_0.Count(_hash_00000, 2)
	if t.readWriter == nil {
		trace_util_0.Count(_hash_00000, 4)
		return errWriteOnSnapshot
	}
	trace_util_0.Count(_hash_00000, 3)
	return t.updateHash(key, field, func([]byte) ([]byte, error) {
		trace_util_0.Count(_hash_00000, 5)
		return value, nil
	})
}

// HGet gets the value of a hash field.
func (t *TxStructure) HGet(key []byte, field []byte) ([]byte, error) {
	trace_util_0.Count(_hash_00000, 6)
	dataKey := t.encodeHashDataKey(key, field)
	value, err := t.reader.Get(dataKey)
	if kv.ErrNotExist.Equal(err) {
		trace_util_0.Count(_hash_00000, 8)
		err = nil
	}
	trace_util_0.Count(_hash_00000, 7)
	return value, errors.Trace(err)
}

func (t *TxStructure) hashFieldIntegerVal(val int64) []byte {
	trace_util_0.Count(_hash_00000, 9)
	return []byte(strconv.FormatInt(val, 10))
}

// EncodeHashAutoIDKeyValue returns the hash key-value generated by the key and the field
func (t *TxStructure) EncodeHashAutoIDKeyValue(key []byte, field []byte, val int64) (k, v []byte) {
	trace_util_0.Count(_hash_00000, 10)
	return t.encodeHashDataKey(key, field), t.hashFieldIntegerVal(val)
}

// HInc increments the integer value of a hash field, by step, returns
// the value after the increment.
func (t *TxStructure) HInc(key []byte, field []byte, step int64) (int64, error) {
	trace_util_0.Count(_hash_00000, 11)
	if t.readWriter == nil {
		trace_util_0.Count(_hash_00000, 14)
		return 0, errWriteOnSnapshot
	}
	trace_util_0.Count(_hash_00000, 12)
	base := int64(0)
	err := t.updateHash(key, field, func(oldValue []byte) ([]byte, error) {
		trace_util_0.Count(_hash_00000, 15)
		if oldValue != nil {
			trace_util_0.Count(_hash_00000, 17)
			var err error
			base, err = strconv.ParseInt(string(oldValue), 10, 64)
			if err != nil {
				trace_util_0.Count(_hash_00000, 18)
				return nil, errors.Trace(err)
			}
		}
		trace_util_0.Count(_hash_00000, 16)
		base += step
		return t.hashFieldIntegerVal(base), nil
	})

	trace_util_0.Count(_hash_00000, 13)
	return base, errors.Trace(err)
}

// HGetInt64 gets int64 value of a hash field.
func (t *TxStructure) HGetInt64(key []byte, field []byte) (int64, error) {
	trace_util_0.Count(_hash_00000, 19)
	value, err := t.HGet(key, field)
	if err != nil || value == nil {
		trace_util_0.Count(_hash_00000, 21)
		return 0, errors.Trace(err)
	}

	trace_util_0.Count(_hash_00000, 20)
	var n int64
	n, err = strconv.ParseInt(string(value), 10, 64)
	return n, errors.Trace(err)
}

func (t *TxStructure) updateHash(key []byte, field []byte, fn func(oldValue []byte) ([]byte, error)) error {
	trace_util_0.Count(_hash_00000, 22)
	dataKey := t.encodeHashDataKey(key, field)
	oldValue, err := t.loadHashValue(dataKey)
	if err != nil {
		trace_util_0.Count(_hash_00000, 29)
		return errors.Trace(err)
	}

	trace_util_0.Count(_hash_00000, 23)
	newValue, err := fn(oldValue)
	if err != nil {
		trace_util_0.Count(_hash_00000, 30)
		return errors.Trace(err)
	}

	// Check if new value is equal to old value.
	trace_util_0.Count(_hash_00000, 24)
	if bytes.Equal(oldValue, newValue) {
		trace_util_0.Count(_hash_00000, 31)
		return nil
	}

	trace_util_0.Count(_hash_00000, 25)
	if err = t.readWriter.Set(dataKey, newValue); err != nil {
		trace_util_0.Count(_hash_00000, 32)
		return errors.Trace(err)
	}

	trace_util_0.Count(_hash_00000, 26)
	metaKey := t.encodeHashMetaKey(key)
	meta, err := t.loadHashMeta(metaKey)
	if err != nil {
		trace_util_0.Count(_hash_00000, 33)
		return errors.Trace(err)
	}

	trace_util_0.Count(_hash_00000, 27)
	if oldValue == nil {
		trace_util_0.Count(_hash_00000, 34)
		meta.FieldCount++
		if err = t.readWriter.Set(metaKey, meta.Value()); err != nil {
			trace_util_0.Count(_hash_00000, 35)
			return errors.Trace(err)
		}
	}

	trace_util_0.Count(_hash_00000, 28)
	return nil
}

// HLen gets the number of fields in a hash.
func (t *TxStructure) HLen(key []byte) (int64, error) {
	trace_util_0.Count(_hash_00000, 36)
	metaKey := t.encodeHashMetaKey(key)
	meta, err := t.loadHashMeta(metaKey)
	if err != nil {
		trace_util_0.Count(_hash_00000, 38)
		return 0, errors.Trace(err)
	}
	trace_util_0.Count(_hash_00000, 37)
	return meta.FieldCount, nil
}

// HDel deletes one or more hash fields.
func (t *TxStructure) HDel(key []byte, fields ...[]byte) error {
	trace_util_0.Count(_hash_00000, 39)
	if t.readWriter == nil {
		trace_util_0.Count(_hash_00000, 44)
		return errWriteOnSnapshot
	}
	trace_util_0.Count(_hash_00000, 40)
	metaKey := t.encodeHashMetaKey(key)
	meta, err := t.loadHashMeta(metaKey)
	if err != nil || meta.IsEmpty() {
		trace_util_0.Count(_hash_00000, 45)
		return errors.Trace(err)
	}

	trace_util_0.Count(_hash_00000, 41)
	var value []byte
	for _, field := range fields {
		trace_util_0.Count(_hash_00000, 46)
		dataKey := t.encodeHashDataKey(key, field)

		value, err = t.loadHashValue(dataKey)
		if err != nil {
			trace_util_0.Count(_hash_00000, 48)
			return errors.Trace(err)
		}

		trace_util_0.Count(_hash_00000, 47)
		if value != nil {
			trace_util_0.Count(_hash_00000, 49)
			if err = t.readWriter.Delete(dataKey); err != nil {
				trace_util_0.Count(_hash_00000, 51)
				return errors.Trace(err)
			}

			trace_util_0.Count(_hash_00000, 50)
			meta.FieldCount--
		}
	}

	trace_util_0.Count(_hash_00000, 42)
	if meta.IsEmpty() {
		trace_util_0.Count(_hash_00000, 52)
		err = t.readWriter.Delete(metaKey)
	} else {
		trace_util_0.Count(_hash_00000, 53)
		{
			err = t.readWriter.Set(metaKey, meta.Value())
		}
	}

	trace_util_0.Count(_hash_00000, 43)
	return errors.Trace(err)
}

// HKeys gets all the fields in a hash.
func (t *TxStructure) HKeys(key []byte) ([][]byte, error) {
	trace_util_0.Count(_hash_00000, 54)
	var keys [][]byte
	err := t.iterateHash(key, func(field []byte, value []byte) error {
		trace_util_0.Count(_hash_00000, 56)
		keys = append(keys, append([]byte{}, field...))
		return nil
	})

	trace_util_0.Count(_hash_00000, 55)
	return keys, errors.Trace(err)
}

// HGetAll gets all the fields and values in a hash.
func (t *TxStructure) HGetAll(key []byte) ([]HashPair, error) {
	trace_util_0.Count(_hash_00000, 57)
	var res []HashPair
	err := t.iterateHash(key, func(field []byte, value []byte) error {
		trace_util_0.Count(_hash_00000, 59)
		pair := HashPair{
			Field: append([]byte{}, field...),
			Value: append([]byte{}, value...),
		}
		res = append(res, pair)
		return nil
	})

	trace_util_0.Count(_hash_00000, 58)
	return res, errors.Trace(err)
}

// HGetLastN gets latest N fields and values in hash.
func (t *TxStructure) HGetLastN(key []byte, num int) ([]HashPair, error) {
	trace_util_0.Count(_hash_00000, 60)
	res := make([]HashPair, 0, num)
	err := t.iterReverseHash(key, func(field []byte, value []byte) (bool, error) {
		trace_util_0.Count(_hash_00000, 62)
		pair := HashPair{
			Field: append([]byte{}, field...),
			Value: append([]byte{}, value...),
		}
		res = append(res, pair)
		if len(res) >= num {
			trace_util_0.Count(_hash_00000, 64)
			return false, nil
		}
		trace_util_0.Count(_hash_00000, 63)
		return true, nil
	})
	trace_util_0.Count(_hash_00000, 61)
	return res, errors.Trace(err)
}

// HClear removes the hash value of the key.
func (t *TxStructure) HClear(key []byte) error {
	trace_util_0.Count(_hash_00000, 65)
	metaKey := t.encodeHashMetaKey(key)
	meta, err := t.loadHashMeta(metaKey)
	if err != nil || meta.IsEmpty() {
		trace_util_0.Count(_hash_00000, 69)
		return errors.Trace(err)
	}

	trace_util_0.Count(_hash_00000, 66)
	err = t.iterateHash(key, func(field []byte, value []byte) error {
		trace_util_0.Count(_hash_00000, 70)
		k := t.encodeHashDataKey(key, field)
		return errors.Trace(t.readWriter.Delete(k))
	})

	trace_util_0.Count(_hash_00000, 67)
	if err != nil {
		trace_util_0.Count(_hash_00000, 71)
		return errors.Trace(err)
	}

	trace_util_0.Count(_hash_00000, 68)
	return errors.Trace(t.readWriter.Delete(metaKey))
}

func (t *TxStructure) iterateHash(key []byte, fn func(k []byte, v []byte) error) error {
	trace_util_0.Count(_hash_00000, 72)
	dataPrefix := t.hashDataKeyPrefix(key)
	it, err := t.reader.Iter(dataPrefix, dataPrefix.PrefixNext())
	if err != nil {
		trace_util_0.Count(_hash_00000, 75)
		return errors.Trace(err)
	}

	trace_util_0.Count(_hash_00000, 73)
	var field []byte

	for it.Valid() {
		trace_util_0.Count(_hash_00000, 76)
		if !it.Key().HasPrefix(dataPrefix) {
			trace_util_0.Count(_hash_00000, 80)
			break
		}

		trace_util_0.Count(_hash_00000, 77)
		_, field, err = t.decodeHashDataKey(it.Key())
		if err != nil {
			trace_util_0.Count(_hash_00000, 81)
			return errors.Trace(err)
		}

		trace_util_0.Count(_hash_00000, 78)
		if err = fn(field, it.Value()); err != nil {
			trace_util_0.Count(_hash_00000, 82)
			return errors.Trace(err)
		}

		trace_util_0.Count(_hash_00000, 79)
		err = it.Next()
		if err != nil {
			trace_util_0.Count(_hash_00000, 83)
			return errors.Trace(err)
		}
	}

	trace_util_0.Count(_hash_00000, 74)
	return nil
}

func (t *TxStructure) iterReverseHash(key []byte, fn func(k []byte, v []byte) (bool, error)) error {
	trace_util_0.Count(_hash_00000, 84)
	dataPrefix := t.hashDataKeyPrefix(key)
	it, err := t.reader.IterReverse(dataPrefix.PrefixNext())
	if err != nil {
		trace_util_0.Count(_hash_00000, 87)
		return errors.Trace(err)
	}

	trace_util_0.Count(_hash_00000, 85)
	var field []byte
	for it.Valid() {
		trace_util_0.Count(_hash_00000, 88)
		if !it.Key().HasPrefix(dataPrefix) {
			trace_util_0.Count(_hash_00000, 92)
			break
		}

		trace_util_0.Count(_hash_00000, 89)
		_, field, err = t.decodeHashDataKey(it.Key())
		if err != nil {
			trace_util_0.Count(_hash_00000, 93)
			return errors.Trace(err)
		}

		trace_util_0.Count(_hash_00000, 90)
		more, err := fn(field, it.Value())
		if !more || err != nil {
			trace_util_0.Count(_hash_00000, 94)
			return errors.Trace(err)
		}

		trace_util_0.Count(_hash_00000, 91)
		err = it.Next()
		if err != nil {
			trace_util_0.Count(_hash_00000, 95)
			return errors.Trace(err)
		}
	}
	trace_util_0.Count(_hash_00000, 86)
	return nil
}

func (t *TxStructure) loadHashMeta(metaKey []byte) (hashMeta, error) {
	trace_util_0.Count(_hash_00000, 96)
	v, err := t.reader.Get(metaKey)
	if kv.ErrNotExist.Equal(err) {
		trace_util_0.Count(_hash_00000, 101)
		err = nil
	}
	trace_util_0.Count(_hash_00000, 97)
	if err != nil {
		trace_util_0.Count(_hash_00000, 102)
		return hashMeta{}, errors.Trace(err)
	}

	trace_util_0.Count(_hash_00000, 98)
	meta := hashMeta{FieldCount: 0}
	if v == nil {
		trace_util_0.Count(_hash_00000, 103)
		return meta, nil
	}

	trace_util_0.Count(_hash_00000, 99)
	if len(v) != 8 {
		trace_util_0.Count(_hash_00000, 104)
		return meta, errInvalidListMetaData
	}

	trace_util_0.Count(_hash_00000, 100)
	meta.FieldCount = int64(binary.BigEndian.Uint64(v[0:8]))
	return meta, nil
}

func (t *TxStructure) loadHashValue(dataKey []byte) ([]byte, error) {
	trace_util_0.Count(_hash_00000, 105)
	v, err := t.reader.Get(dataKey)
	if kv.ErrNotExist.Equal(err) {
		trace_util_0.Count(_hash_00000, 108)
		err = nil
		v = nil
	}
	trace_util_0.Count(_hash_00000, 106)
	if err != nil {
		trace_util_0.Count(_hash_00000, 109)
		return nil, errors.Trace(err)
	}

	trace_util_0.Count(_hash_00000, 107)
	return v, nil
}

var _hash_00000 = "structure/hash.go"
